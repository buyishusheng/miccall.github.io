<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Mr.Metro
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<link rel="stylesheet" href="/css/prism-coy.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(undefined);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Android学习笔记 010</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <hr>
<h1 id="Android学习笔记"><a href="#Android学习笔记" class="headerlink" title=" Android学习笔记 "></a><strong> Android学习笔记 </strong></h1><h2 id="系统程序和用户程序拆分"><a href="#系统程序和用户程序拆分" class="headerlink" title="系统程序和用户程序拆分"></a>系统程序和用户程序拆分</h2><pre><code>1.将集合拆分,分别保存
        @Override
        public void doinBack() {
            list = AppEngine.getAppInfos(getApplicationContext());
            userappinfo = new ArrayList&lt;AppInfo&gt;();
            systemappinfo = new ArrayList&lt;AppInfo&gt;();
            for (AppInfo appinfo : list) {
                //将数据分别存放到用户程序集合和系统程序集合中
                if (appinfo.isUser()) {
                    userappinfo.add(appinfo);
                }else{
                    systemappinfo.add(appinfo);
                }
            }
        }
2.修改adapter的getcount返回值
        @Override
        public int getCount() {
            // TODO Auto-generated method stub
            //list.size() = userappinfo.size()+systemappinfo.size()
            return userappinfo.size()+systemappinfo.size()+2;
        }
3.在getview中增加条目,并获取数据

    增加条目
        if (position == 0) {
            //添加用户程序(...个)textview
            TextView textView = new TextView(getApplicationContext());
            textView.setBackgroundColor(Color.GRAY);
            textView.setTextColor(Color.WHITE);
            textView.setText(&quot;用户程序(&quot;+userappinfo.size()+&quot;)&quot;);
            return textView;
        }else if(position == userappinfo.size()+1){
            //添加系统程序(....个)textview
            TextView textView = new TextView(getApplicationContext());
            textView.setBackgroundColor(Color.GRAY);
            textView.setTextColor(Color.WHITE);
            textView.setText(&quot;系统程序(&quot;+systemappinfo.size()+&quot;)&quot;);
            return textView;
        }
    获取数据
        //1.获取应用程序的信息
        AppInfo appInfo;
        //数据就要从userappinfo和systemappinfo中获取
        if (position &lt;= userappinfo.size()) {
            //用户程序
            appInfo = userappinfo.get(position-1);
        }else{
            //系统程序
            appInfo = systemappinfo.get(position - userappinfo.size() - 2);
        }

    判断缓存复用
        if (convertView != null &amp;&amp; convertView instanceof RelativeLayout) {
            view = convertView;
            viewHolder = (ViewHolder) view.getTag();
        }else{
</code></pre><h2 id="浮动显示程序个数"><a href="#浮动显示程序个数" class="headerlink" title="浮动显示程序个数"></a>浮动显示程序个数</h2><pre><code>/**
 * listview滑动监听事件
 */
private void listviewOnscroll() {
    lv_softmanager_application.setOnScrollListener(new OnScrollListener() {
        //滑动状态改变的时候调用
        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {
            // TODO Auto-generated method stub

        }
        //滑动的时候调用
        //view : listview
        //firstVisibleItem : 界面第一个显示条目
        //visibleItemCount : 显示条目总个数
        //totalItemCount : 条目的总个数
        @Override
        public void onScroll(AbsListView view, int firstVisibleItem,
                int visibleItemCount, int totalItemCount) {
            //为null的原因:listview在初始化的时候就会调用onScroll方法
            if (userappinfo != null &amp;&amp; systemappinfo != null) {
                if (firstVisibleItem &gt;= userappinfo.size()+1) {
                    tv_softmanager_userorsystem.setText(&quot;系统程序(&quot;+systemappinfo.size()+&quot;)&quot;);  
                }else{
                    tv_softmanager_userorsystem.setText(&quot;用户程序(&quot;+userappinfo.size()+&quot;)&quot;);    
                }
            }
        }
    });
}
</code></pre><h2 id="popuwindow操作-重点"><a href="#popuwindow操作-重点" class="headerlink" title="popuwindow操作#  (重点)"></a>popuwindow操作#  (重点)</h2><pre><code>/**
 * 条目点击事件
 */
private void listviewItemClick() {
    lv_softmanager_application.setOnItemClickListener(new OnItemClickListener() {

        //view : 条目的view对象
        @Override
        public void onItemClick(AdapterView&lt;?&gt; parent, View view,
                int position, long id) {
            //弹出气泡
            //1.屏蔽用户程序和系统程序(...个)弹出气泡
            if (position == 0 || position == userappinfo.size()+1) {
                return;
            }
            //2.获取条目所对应的应用程序的信息
            //数据就要从userappinfo和systemappinfo中获取
            if (position &lt;= userappinfo.size()) {
                //用户程序
                appInfo = userappinfo.get(position-1);
            }else{
                //系统程序
                appInfo = systemappinfo.get(position - userappinfo.size() - 2);
            }
            //5.弹出新的气泡之前,删除旧 的气泡
            hidePopuwindow();
            //3.弹出气泡
            /*TextView contentView = new TextView(getApplicationContext());
            contentView.setText(&quot;我是popuwindow的textview控件&quot;);
            contentView.setBackgroundColor(Color.RED);*/
            View contentView = View.inflate(getApplicationContext(), R.layout.popu_window, null);
            //contentView : 显示view对象
            //width,height : view宽高
            popupWindow = new PopupWindow(contentView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            //4.获取条目的位置,让气泡显示在相应的条目
            int[] location = new int[2];//保存x和y坐标的数组
            view.getLocationInWindow(location);//获取条目x和y的坐标,同时保存到int[]
            //获取x和y的坐标
            int x = location[0];
            int y = location[1];
            //parent : 要挂载在那个控件上
            //gravity,x,y : 控制popuwindow显示的位置
            popupWindow.showAtLocation(parent, Gravity.LEFT | Gravity.TOP, x+50, y);
        }

    });
}

隐藏气泡
    /**
     * 隐藏气泡
     */
    private void hidePopuwindow() {
        if (popupWindow != null) {
            popupWindow.dismiss();//隐藏气泡
            popupWindow = null;
        }
    }
</code></pre><h2 id="popuwindow动画-重点"><a href="#popuwindow动画-重点" class="headerlink" title="popuwindow动画# (重点)"></a>popuwindow动画# (重点)</h2><pre><code>动画要想执行,执行的控件必须有背景,动画都是基于背景来进行一些计算,没有背景动画是无法执行,popuwindow默认是没有设置背景

//6.设置动画
            //缩放动画
            //前四个 :　控制控件由没有变到有   动画 0:没有    1:整个控件
            //后四个:控制控件是按照自身还是父控件进行变化
            //RELATIVE_TO_SELF : 以自身变化
            //RELATIVE_TO_PARENT : 以父控件变化
            ScaleAnimation scaleAnimation = new ScaleAnimation(0, 1, 0, 1, Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0.5f);
            scaleAnimation.setDuration(500);

            //渐变动画
            AlphaAnimation alphaAnimation = new AlphaAnimation(0.4f, 1.0f);//由半透明变成不透明
            alphaAnimation.setDuration(500);

            //组合动画
            //shareInterpolator : 是否使用相同的动画插补器  true:共享    false:各自使用各自的
            AnimationSet animationSet = new AnimationSet(true);
            //添加动画
            animationSet.addAnimation(scaleAnimation);
            animationSet.addAnimation(alphaAnimation);
            //执行动画
            contentView.startAnimation(animationSet);
给popuwindow设置背景
    popupWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
</code></pre><h2 id="设置控件点击事件"><a href="#设置控件点击事件" class="headerlink" title="设置控件点击事件"></a>设置控件点击事件</h2><pre><code>1.初始化控件
            //初始化控件
            LinearLayout ll_popuwindow_uninstall = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_uninstall);
            LinearLayout ll_popuwindow_start = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_start);
            LinearLayout ll_popuwindow_share = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_share);
            LinearLayout ll_popuwindow_detail = (LinearLayout) contentView.findViewById(R.id.ll_popuwindow_detail);
2.activity实现点击事件接口,并实现相应的点击事件方法,同时设置控件点击事件
        public class SoftMangaerActivity extends Activity implements OnClickListener {

            //给控件设置点击事件
            ll_popuwindow_uninstall.setOnClickListener(SoftMangaerActivity.this);
            ll_popuwindow_start.setOnClickListener(SoftMangaerActivity.this);
            ll_popuwindow_share.setOnClickListener(SoftMangaerActivity.this);
            ll_popuwindow_detail.setOnClickListener(SoftMangaerActivity.this);

        @Override
        public void onClick(View v) {
            //判断点击是按个按钮
            //getId() : 获取点击按钮的id
            switch (v.getId()) {
            case R.id.ll_popuwindow_uninstall:
                System.out.println(&quot;卸载&quot;);
                break;
            case R.id.ll_popuwindow_start:
                System.out.println(&quot;启动&quot;);
                break;
            case R.id.ll_popuwindow_share:
                System.out.println(&quot;分享&quot;);
                break;
            case R.id.ll_popuwindow_detail:
                System.out.println(&quot;详情&quot;);
                break;
            }
        }
</code></pre><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><pre><code>    /**
     * 卸载
     */
    private void uninstall() {
        /**
         * &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
                &lt;action android:name=&quot;android.intent.action.DELETE&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
                &lt;data android:scheme=&quot;package&quot; /&gt;
            &lt;/intent-filter&gt;
         */
        //判断是否是系统程序
        if (appInfo.isUser()) {
            //判断是否是我们自己的应用,是不能卸载
            if (!appInfo.getPackagName().equals(getPackageName())) {
                Intent intent = new Intent();
                intent.setAction(&quot;android.intent.action.DELETE&quot;);
                intent.addCategory(&quot;android.intent.category.DEFAULT&quot;);
                intent.setData(Uri.parse(&quot;package:&quot;+appInfo.getPackagName()));//tel:110
                startActivityForResult(intent,0);
            }else{
                Toast.makeText(getApplicationContext(), &quot;文明社会,杜绝自杀&quot;, 0).show();
            }
        }else{
            Toast.makeText(getApplicationContext(), &quot;要想卸载系统程序,请root先&quot;, 0).show();
        }
    }
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        fillData();
    }
</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code>/**
 * 启动
 */
private void start() {
    PackageManager pm = getPackageManager();
    //获取应用程序的启动意图
    Intent intent = pm.getLaunchIntentForPackage(appInfo.getPackagName());
    if (intent!=null) {
        startActivity(intent);
    }else{
        Toast.makeText(getApplicationContext(), &quot;系统核心程序,无法启动&quot;, 0).show();
    }
}
</code></pre><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><pre><code>通过系统log查看跳转操作

/**
 *详情
 */
private void detail() {
    /**
     *  Intent 
        { 
        act=android.settings.APPLICATION_DETAILS_SETTINGS    action
        dat=package:com.example.android.apis   data
        cmp=com.android.settings/.applications.InstalledAppDetails 
        } from pid 228
     */
    Intent intent = new Intent();
    intent.setAction(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;);
    intent.setData(Uri.parse(&quot;package:&quot;+appInfo.getPackagName()));
    startActivity(intent);
}
</code></pre><h2 id="分享-重点"><a href="#分享-重点" class="headerlink" title="分享# (重点)"></a>分享# (重点)</h2><pre><code>1.分享
    /**
     *  Intent 
        { 
            act=android.intent.action.SEND 
            typ=text/plain 
            flg=0x3000000 
            cmp=com.android.mms/.ui.ComposeMessageActivity (has extras)   intent中包含信息
        } from pid 228
     */
    Intent intent = new Intent();
    intent.setAction(&quot;android.intent.action.SEND&quot;);
    intent.setType(&quot;text/plain&quot;);
    intent.putExtra(Intent.EXTRA_TEXT, &quot;发现一个很牛x软件&quot;+appInfo.getName()+&quot;,下载地址:www.baidu.com,自己去搜&quot;);
    startActivity(intent);
2.如果是应用能够进行分享操作
    a.在activity中添加意图
        &lt;!-- 表名应用程序能够接受分享信息 --&gt;
        &lt;intent-filter&gt;
           &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;
           &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
           &lt;data android:mimeType=&quot;text/plain&quot; /&gt;
       &lt;/intent-filter&gt;
    b.接受分享信息
        Intent intent = getIntent();
        String stringExtra = intent.getStringExtra(Intent.EXTRA_TEXT);
        if (!TextUtils.isEmpty(stringExtra)) {
            iv_share.setText(stringExtra);
        }

shareSDK
</code></pre><h2 id="获取可用空间"><a href="#获取可用空间" class="headerlink" title="获取可用空间"></a>获取可用空间</h2><pre><code>1.apputil
    /**
     * 获取SD卡可用空间
     */
    public static long getAvailableSD(){
         //获取SD卡路径
         File path = Environment.getExternalStorageDirectory();
         //硬盘的API操作
         StatFs stat = new StatFs(path.getPath());
         long blockSize = stat.getBlockSize();//获取每块的大小
         long totalBlocks = stat.getBlockCount();//获取总块数
         long availableBlocks = stat.getAvailableBlocks();//获取可用的块数
         return availableBlocks*blockSize;
    }
    /**
     *获取内存可用空间
     * @return
     */
    public static long getAvailableROM(){
        //获取内存路径
        File path = Environment.getDataDirectory();
        //硬盘的API操作
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();//获取每块的大小
        long totalBlocks = stat.getBlockCount();//获取总块数
        long availableBlocks = stat.getAvailableBlocks();//获取可用的块数
        return availableBlocks*blockSize;
    }
2.使用
    //获取可用内存,获取都是kb
    long availableSD = AppUtil.getAvailableSD();
    long availableROM = AppUtil.getAvailableROM();
    //数据转化
    String sdsize = Formatter.formatFileSize(getApplicationContext(), availableSD);
    String romsize = Formatter.formatFileSize(getApplicationContext(), availableROM);
    //设置显示
    tv_softmanager_sd.setText(&quot;SD卡可用:&quot;+sdsize);
    tv_softmanager_rom.setText(&quot;内存可用:&quot;+romsize);
</code></pre><h2 id="获取系统所有进程信息-重点"><a href="#获取系统所有进程信息-重点" class="headerlink" title="获取系统所有进程信息# (重点)"></a>获取系统所有进程信息# (重点)</h2><pre><code>/**
 * 获取系统中所有进程信息
 * @return
 */
public static List&lt;TaskInfo&gt; getTaskAllInfo(Context context){
    List&lt;TaskInfo&gt; list = new ArrayList&lt;TaskInfo&gt;();
    //1.进程的管理者
    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    PackageManager pm = context.getPackageManager();
    //2.获取所有正在运行的进程信息
    List&lt;RunningAppProcessInfo&gt; runningAppProcesses = activityManager.getRunningAppProcesses();
    //遍历集合
    for (RunningAppProcessInfo runningAppProcessInfo : runningAppProcesses) {
        TaskInfo taskInfo = new TaskInfo();
        //3.获取相应的信息
        //获取进程的名称,获取包名
        String packagName = runningAppProcessInfo.processName;
        taskInfo.setPackageName(packagName);
        //获取进程所占的内存空间,int[] pids : 输入几个进程的pid,就会返回几个进程所占的空间
        MemoryInfo[] memoryInfo = activityManager.getProcessMemoryInfo(new int[]{runningAppProcessInfo.pid});
        int totalPss = memoryInfo[0].getTotalPss();
        long ramSize = totalPss*1024;
        taskInfo.setRamSize(ramSize);
        try {
            //获取application信息
            //packageName : 包名     flags:指定信息标签
            ApplicationInfo applicationInfo = pm.getApplicationInfo(packagName, 0);
            //获取图标
            Drawable icon = applicationInfo.loadIcon(pm);
            taskInfo.setIcon(icon);
            //获取名称
            String name = applicationInfo.loadLabel(pm).toString();
            taskInfo.setName(name);
            //获取程序的所有标签信息,是否是系统程序是以标签的形式展示
            int flags = applicationInfo.flags;
            boolean isUser;
            //判断是否是用户程序
            if ((applicationInfo.FLAG_SYSTEM &amp; flags) == applicationInfo.FLAG_SYSTEM) {
                //系统程序
                isUser = false;
            }else{
                //用户程序
                isUser = true;
            }
            //保存信息
            taskInfo.setUser(isUser);
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }
        //taskinfo添加到集合
        list.add(taskInfo);
    }
    return list;
}
</code></pre><h2 id="进程管理界面-重点-思路"><a href="#进程管理界面-重点-思路" class="headerlink" title="进程管理界面# (重点:思路)"></a>进程管理界面# (重点:思路)</h2><pre><code>按照软件管理思路一步步复制
</code></pre><h2 id="checkboxBug解决-重点"><a href="#checkboxBug解决-重点" class="headerlink" title="checkboxBug解决#  (重点)"></a>checkboxBug解决#  (重点)</h2><pre><code>问题:checkbox的状态会跟着控件一起复用,
解决:所以将状态保存到bean类中,根据bean中保存的状态在getview中进行动态设置
1.将状态设置到bean类中
    //checkbox是否被选中
    private boolean isChecked = false;
2.在getview中进行动态判断设置
        //因为checkbox的状态会跟着一起复用,所以一般要动态修改的控件的状态,不会跟着去复用,而是将状态保存到bean对象,在每次复用使用控件的时候
        //根据每个条目对应的bean对象保存的状态,来设置控件显示的相应的状态
        if (taskinfo.isChecked()) {
            viewHolder.cb_itemtaskmanager_ischecked.setChecked(true);
        }else{
            viewHolder.cb_itemtaskmanager_ischecked.setChecked(false);
        }
3.屏蔽checkbox的获取焦点和点击事件
    &lt;CheckBox 
        android:id=&quot;@+id/cb_itemtaskmanager_ischecked&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentRight=&quot;true&quot;
        android:layout_centerVertical=&quot;true&quot;
        android:layout_marginRight=&quot;15dp&quot;
        android:focusable=&quot;false&quot;
        android:clickable=&quot;false&quot;
        /&gt;
4.屏蔽之后,发现点击条目无法更改checkbox的状态,所以设置条目点击事件进行更改
    /**
     * listview条目点击事件
     */
    private void listviewItemClick() {
        lv_taskmanager_processes.setOnItemClickListener(new OnItemClickListener() {
            //view : 条目的view对象
            @Override
            public void onItemClick(AdapterView&lt;?&gt; parent, View view,
                    int position, long id) {
                //动态改变checkbox状态
                //1.屏蔽用户程序和系统程序(...个)弹出气泡
                if (position == 0 || position == userappinfo.size()+1) {
                    return;
                }
                //2.获取条目所对应的应用程序的信息
                //数据就要从userappinfo和systemappinfo中获取
                if (position &lt;= userappinfo.size()) {
                    //用户程序
                    taskInfo = userappinfo.get(position-1);
                }else{
                    //系统程序
                    taskInfo = systemappinfo.get(position - userappinfo.size() - 2);
                }
                //3.根据之前保存的checkbox的状态设置点击之后的状态,原先选中,点击之后不选中
                if (taskInfo.isChecked()) {
                    taskInfo.setChecked(false);
                }else{
                    taskInfo.setChecked(true);
                }
                //4.更新界面
                //myadapter.notifyDataSetChanged();
                //只更新点击的条目
                ViewHolder viewHolder = (ViewHolder) view.getTag();
                viewHolder.cb_itemtaskmanager_ischecked.setChecked(taskInfo.isChecked());
            }
        });
    }
5.单独更新单个条目
    因为控件是保存在ViewHolder控件容器中,而容器又是在listview条目展示的时候通过view.settag和view对象进行绑定了,那我们就可以在条目点击事件进行使用处理,因为在条目点击事件中有view参数,这个参数代表就是点击条目的view对象,通过view.gettag获取到和view对象绑定的容器,从容器中获取控件,设置控件的状态了
</code></pre><h2 id="全选和取消"><a href="#全选和取消" class="headerlink" title="全选和取消"></a>全选和取消</h2><pre><code>    /**
     * 全选
     * @param v
     */
    public void all(View v){
        //用户进程
        for (int i = 0; i &lt; userappinfo.size(); i++) {
            userappinfo.get(i).setChecked(true);
        }
        //系统进程
        for (int i = 0; i &lt; systemappinfo.size(); i++) {
            systemappinfo.get(i).setChecked(true);
        }
        //更新界面
        myadapter.notifyDataSetChanged();
    }
    /**
     * 取消
     * @param v
     */
    public void cancel(View v){
        //用户进程
        for (int i = 0; i &lt; userappinfo.size(); i++) {
            userappinfo.get(i).setChecked(false);
        }
        //系统进程
        for (int i = 0; i &lt; systemappinfo.size(); i++) {
            systemappinfo.get(i).setChecked(false);
        }
        //更新界面
        myadapter.notifyDataSetChanged();
    }
</code></pre><h2 id="清理进程-重点-五个进程"><a href="#清理进程-重点-五个进程" class="headerlink" title="清理进程# (重点:五个进程)"></a>清理进程# (重点:五个进程)</h2><pre><code>android进程
    1.前台进程  正在操作的进程,正在运行进程,不可杀死
    2.可见进程  没有焦点,但是可见的进程
    3.服务进程  包含服务的进程,当内存不足的时候,会被杀掉,当内存充足的时候,重新服务进程
    4.后台进程  点击home键,最小化
    5.空进程    退出,为了下次能够快速启动

后台进程和空进程是可以通过代码杀死

/**
 * 清理
 * @param v
 */
public void clear(View v){
    //1.获取进程的管理者
    ActivityManager am = (ActivityManager) getSystemService(ACTIVITY_SERVICE);
    //保存杀死进程信息的集合
    List&lt;TaskInfo&gt; deleteTaskInfos = new ArrayList&lt;TaskInfo&gt;();

    for (int i = 0; i &lt; userappinfo.size(); i++) {
        if (userappinfo.get(i).isChecked()) {
            //杀死进程
            //packageName : 进程的包名
            //杀死后台进程
            am.killBackgroundProcesses(userappinfo.get(i).getPackageName());
            deleteTaskInfos.add(userappinfo.get(i));//将杀死的进程信息保存的集合中
        }
    }
    //系统进程
    for (int i = 0; i &lt; systemappinfo.size(); i++) {
        if (systemappinfo.get(i).isChecked()) {
            //杀死进程
            //packageName : 进程的包名
            //杀死后台进程
            am.killBackgroundProcesses(systemappinfo.get(i).getPackageName());
            deleteTaskInfos.add(systemappinfo.get(i));//将杀死的进程信息保存的集合中
        }
    }
    //遍历deleteTaskInfos,分别从userappinfo和systemappinfo中删除deleteTaskInfos中的数据
    for (TaskInfo taskInfo : deleteTaskInfos) {
        if (taskInfo.isUser()) {
            userappinfo.remove(taskInfo);
        }else{
            systemappinfo.remove(taskInfo);
        }
    }
    //为下次清理进程做准备
    deleteTaskInfos.clear();
    deleteTaskInfos=null;
    //更新界面
    myadapter.notifyDataSetChanged();
}

权限
&lt;uses-permission android:name=&quot;android.permission.KILL_BACKGROUND_PROCESSES&quot;/&gt;
</code></pre><h2 id="清理细节处理"><a href="#清理细节处理" class="headerlink" title="清理细节处理"></a>清理细节处理</h2><pre><code>1.设置清理显示
    long memory=0;
    //遍历deleteTaskInfos,分别从userappinfo和systemappinfo中删除deleteTaskInfos中的数据
    for (TaskInfo taskInfo : deleteTaskInfos) {
        if (taskInfo.isUser()) {
            userappinfo.remove(taskInfo);
        }else{
            systemappinfo.remove(taskInfo);
        }
        memory+=taskInfo.getRamSize();
    }
    //数据转化
    String deletesize = Formatter.formatFileSize(getApplicationContext(), memory);
    Toast.makeText(getApplicationContext(), &quot;共清理&quot;+deleteTaskInfos.size()+&quot;个进程,释放&quot;+deletesize+&quot;内存空间&quot;, 0).show();
2.设置当前应用不能选中
    在条目中处理
            //3.根据之前保存的checkbox的状态设置点击之后的状态,原先选中,点击之后不选中
            if (taskInfo.isChecked()) {
                taskInfo.setChecked(false);
            }else{
                //如果是当前应用不能设置成true
                if (!taskInfo.getPackageName().equals(getPackageName())) {
                    taskInfo.setChecked(true);
                }
            }
    在全选中处理
        //用户进程
        for (int i = 0; i &lt; userappinfo.size(); i++) {
            if (!userappinfo.get(i).getPackageName().equals(getPackageName())) {
                userappinfo.get(i).setChecked(true);
            }
        }
3.设置当前应用的checkbox隐藏
    //判断如果是我们的应用程序,就把checkbox隐藏,不是的话显示,在getview中有if必须有else
        if (taskinfo.getPackageName().equals(getPackageName())) {
            viewHolder.cb_itemtaskmanager_ischecked.setVisibility(View.INVISIBLE);
        }else{
            viewHolder.cb_itemtaskmanager_ischecked.setVisibility(View.VISIBLE);
        }
</code></pre>
            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://miccall.tech/android/android_010.html';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://miccall.tech/android/android_010.html'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
            	<span id="busuanzi_container_site_pv">2018总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
